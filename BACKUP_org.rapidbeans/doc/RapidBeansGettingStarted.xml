<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book SYSTEM "docbook.dtd">

<book>
	<title>
		Getting started with RapidBeans
		<author>
			<personname>Martin Blümel</personname>
		</author>
	</title>
	<preface>
		<para>
			In the following you'll work through a coherent example which will
			demonstrate the core assets of RapidBeans. In case you've already
			worked trough the "Getting Started in 10 Minutes" example you
			may skip the first two chapters.
		</para>
	</preface>
	<chapter>
		<title>Preconditions</title>
		<para>
			The minimal prerequisites are:
			<itemizedlist>
				<listitem>
					<para>
						Java Runtime Environment (version >= 1.5) installed at your computer
						(a Java development kit – JDK - is not necessary for your first experience with RapidBeans
						because for this lesson you do not have to code one single line of Java.
						You just model using XML instead).
					</para>
				</listitem>
				<listitem>
					<para>
						You have downloaded and unzipped the example zip file from the
						<link xlink:href="http://www.rapidbeans.org/releases/latest/index.html">RapidBeans download page</link>
						somewhere into your file system (e. g. into C:\tmp).
						<figure>
							<title>the example unpacked on a Windows file system</title>
							<mediaobject>
								<imageobject>
									<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image01a.jpg" />
								</imageobject>
							</mediaobject>
						</figure>
					</para>
				</listitem>
				<listitem>
					<para>
						As development tools you’ll need a text editor (Notepad, Ultraedit, Kate, vi, etc…)
						A command prompt or command shell to start the demo application.
						Most operating systems will provide a mechanism to execute the run script directly.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			In order to get a deeper understanding of this example you should have some experience in:
			Program development in general, object orientation, XML.
			But even If you do not have this knowledge it might be worth having a try.
		</para>
	</chapter>
	<chapter>
		<title>A simple running example</title>
		<subtitle>10 minutes walkthrough</subtitle>
		<para>
			The example will demonstrate a simple "address book" application to store address information about persons.
		</para>
		<section>
			<title>Explore the domain model</title>
			<para>
				The first exercise is to have a look at our application’s simple domain model.
				An address book simply consists of an arbitrary number of persons.
				A person stores last name, first name and the date of birth.
			</para>
			<figure>
				<title>a simple domain model</title>
				<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="RapidBeansGettingStarted-files/image02a.gif"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Instead of a UML model like shown above RapidBeans uses a simple, minimalistic XML dialect
				to express this model which basically lets you define declaratively:
			</para>
			<itemizedlist>
				<listitem><para>bean types (classes)</para></listitem>
				<listitem><para>properties (attributes)</para></listitem>
				<listitem><para>associations - by means of special "association" properties</para></listitem>
				<listitem><para>constraints on property values.</para></listitem>
			</itemizedlist>
			<formalpara>
				<title>File /org/me/addressbook/Person.xml:</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Person">
    <property name="lastname"/>
    <property name="firstname"/>
    <property name="dateofbirth" type="date"/>
</beantype>]]></programlisting>
				</para>
			</formalpara>
			<formalpara>
				<title>File model/org/me/addressbook/Addressbook.xml:</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Addressbook">
    <property name="persons" type="association"
        composition="true"
        targettype="Person"
        sorting="byPropertyValues: lastname, firstname, dateofbirth"
    />
</beantype>]]></programlisting>
				</para>
			</formalpara>
			<para>
				Please note that these two bean type declarations completely describe the UML diagram shown before.
				That would even work out properly without the sorting declaration you see here on the
				"persons" association. This declaration defines the linear order of associated elements
				when accessed through this association.
			</para>
		</section>
		<section>
			<title>Explore the GUI</title>
			<para>
				The second exercise is to start the application by using the run command (Unix: run_en.sh, Windows: run_en.cmd).
				This should immediately open a GUI which presents you an address book according to the schema presented before
				containing some sample data.
			</para>
			<figure>
				<title>the generic RapidBeans GUI presenting a sample addressbook</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image02b.jpg" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				If you are interested you may also try the run_de.cmd / .sh
				which will show the same GUI with German texts.
			</para>
			<para>
				A look at the resource file that defines GUI texts shows that there is not too much
				specific work needed for localization. An interesting aspect may be that translation
				is not done at the level of GUI widgets but instead at the level of bean types
				(classes, entities) and properties (attributes).
			</para>
			<formalpara>
				<title>File res/org/me/addressbook/lang/en/res.xml:</title>
				<para>
					<programlisting><![CDATA[bean.org.me.addressbook.addressbook=Address Book
bean.org.me.addressbook.addressbook.id=Address Book
bean.org.me.addressbook.person=Person
bean.org.me.addressbook.person.id={lastname}, {firstname}
bean.org.me.addressbook.person.plural=Persons
bean.org.me.addressbook.person.prop.dateofbirth=Date of birth
bean.org.me.addressbook.person.prop.firstname=First name
bean.org.me.addressbook.person.prop.lastname=Last name
mainwindow.title=Address Book]]></programlisting>
				</para>
			</formalpara>
			<para>
				The naming is very simple:
			</para>
			<itemizedlist>
				<listitem><para>Bean types are specified with full classname (including all parent packages).</para></listitem>
				<listitem><para>Properties are specified using .prop.&lt;property name&gt; after the classes specification.</para></listitem>
				<listitem>
					<para>
						A special concept is .id. which is not neccessarily the id in the sense of data modelling.
						Here you can specify a speaking name for every instance using property expansion.
					</para>
				</listitem>
				<listitem>
					<para>
						Besides the class centric GUI text specification you could also use the
						classical GUI element centric one where we specify
						window titles, menu texts, etc...
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Explore persisted data</title>
			<para>
				Have a look at file testdata/myaddressbook.xml.
				It is maybe not a big surprise that you find the
				example address book’s data persisted in an XML file:
			</para>
			<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<addressbook>
	<person
		lastname="Edison"
		firstname="Thomas Alva"
		dateofbirth="18470211"
		/>
	<person
		lastname="Einstein"
		firstname="Albert"
		dateofbirth="18790314"
		/>
. . .]]></programlisting>
			<para>
				Please note that in order to have the XML document's root named addressbook,
				you simply add the following small <phrase>xmlbinding</phrase>
				declaration to the Addressbook type definintion.
			</para>
			<programlisting><![CDATA[
<xmlbinding xmlrootelement="addressbook"/>]]></programlisting> 
		</section>

		<section>
			<title>Short wrap up</title>
			<para>
				So far we have seen
				<itemizedlist>
					<listitem><para>a model defining entities</para></listitem>
					<listitem><para>some generic GUI presenting documents composed out of these entities</para></listitem>
					<listitem><para>and some generic persistence storing these document in XML form</para></listitem>
				</itemizedlist>
			</para>
		</section>
	</chapter>

	<chapter>
		<title>Properties, Constraints / Validation, Enumerations / Choices, Quantities</title>
		<para>
			Let's assume we get some new requirements for our small application to provide additional properties for persons:
			<itemizedlist>
				<listitem>
					<para>
						provide a shoe size property:
						"shoesize" is an integer value ranging from 15 to 60
						(provide automatic validation too).
					</para>
				</listitem>
				<listitem>
					<para>
						provide a "sex" property for which lets you choose
						between "male" and "female".
					</para>
				</listitem>
				<listitem>
					<para>
						provide a "height" property for persons.
						Input should be possible using unit "meter" or "centimeter".
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<section>
			<title>Simple data types and declarative constraints</title>
			<para>
				The shoe size property and its contraints are introduced very quickly:
			</para>

			<formalpara>
				<title>File /org/me/addressbook/Person.xml:</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Person">
    <property name="lastname"/>
    <property name="firstname"/>
    <property name="dateofbirth" type="date"/>]]><newcode><![CDATA[
    <property name="shoesize" type="integer"
        minval="15" maxval="60"
    />]]></newcode><![CDATA[
</beantype>]]></programlisting>
				</para>
			</formalpara>
		</section>

		<section>
			<title>Enumerations and choices</title>
			<para>
				Then we create a new enum type Sex simply enumerating "male" and "female"
			</para>

			<formalpara>
				<title>New file /org/me/addressbook/Sex.xml:</title>
				<para>
					<programlisting><newcode><![CDATA[<enumtype name="org.me.addressbook.Sex">
    <enum name="male"/>
    <enum name="female"/>
</enumtype>]]></newcode></programlisting>
				</para>
			</formalpara>

			<para>
				Then we extend the Person bean with a choice property sex.
			</para>

			<formalpara>
				<title>File /org/me/addressbook/Person.xml:</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Person">
    <property name="lastname"/>
    <property name="firstname"/>
    <property name="dateofbirth" type="date"/>]]><newcode><![CDATA[
    <property name="sex" type="choice"
        enum="Sex"
    />]]></newcode><![CDATA[
    <property name="shoesize" type="integer"
        minval="15" maxval="60"
    />
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<para>
				A small experiment you could try is to set this choice property's
				"multiple" constraint to true which would allow to define a person's
				sex to "male" and "female" at the same time. See how the generic
				property editor changes in this case.
				<programlisting><![CDATA[    <property name="sex" type="choice"
        enum="Sex" ]]><newcode>multiple="true"</newcode><![CDATA[
    />]]></programlisting>			
			</para>
		</section>

		<section>
			<title>Units and quantities</title>
			<para>
				Afterwards we specify the new enumeration type UnitLength
				defining some length units and the new quantity type Length
				defining factors between the different units:
			</para>

			<formalpara>
				<title>New file /org/me/addressbook/UnitLength.xml:</title>
				<para>
					<programlisting><newcode><![CDATA[<enumtype name="org.me.addressbook.UnitLength">
    <enum name="meter"/>
    <enum name="centimeter"/>
</enumtype>]]></newcode></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>New file /org/me/addressbook/Length.xml:</title>
				<para>
				   <programlisting><newcode><![CDATA[<quantitytype name="org.me.addressbook.Length" 
    unitenum="UnitLength">
    <unit name="meter" factor="1"/>
    <unit name="centimeter" factor="/1E2"/>
</quantitytype>
]]></newcode></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>File /org/me/addressbook/Person.xml:</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Person">
    <property name="lastname"/>
    <property name="firstname"/>
    <property name="dateofbirth" type="date"/>
    <property name="sex" type="choice"
        enum="Sex"
    />
    <property name="shoesize" type="integer"
        minval="15" maxval="60"
    />]]><newcode><![CDATA[
    <property name="height" type="quantity"
        quantity="Length"
    />]]></newcode><![CDATA[
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<para>
				In order to conclude the first extension step we add the necessary GUI texts.
			</para>

			<formalpara>
				<title>File: res/org/me/addressbook/lang/en/res.xml:</title>
				<para>
				<programlisting><![CDATA[bean.org.me.addressbook.addressbook=Address Book
bean.org.me.addressbook.addressbook.id=Address Book
bean.org.me.addressbook.person=Person
bean.org.me.addressbook.person.id={lastname}, {firstname}
bean.org.me.addressbook.person.plural=Persons
bean.org.me.addressbook.person.prop.dateofbirth=Date of birth
bean.org.me.addressbook.person.prop.firstname=First name]]><newcode><![CDATA[
bean.org.me.addressbook.person.prop.height=Height]]></newcode><![CDATA[
bean.org.me.addressbook.person.prop.lastname=Last name]]><newcode><![CDATA[
bean.org.me.addressbook.person.prop.sex=Sex
bean.org.me.addressbook.person.prop.shoesize=Shoe size
enum.org.me.addressbook.sex.male=male
enum.org.me.addressbook.sex.female=female
enum.org.me.addressbook.unitlength.centimeter=cm
enum.org.me.addressbook.unitlength.meter=m]]></newcode><![CDATA[
mainwindow.title=Address Book]]></programlisting>
				</para>
			</formalpara>

			<para>
				Afterwards the application will present the new properties when started the next time.
			</para>
			<figure>
				<title>The new properties defined and an error message indicating invalid input</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image03a.jpg"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

	</chapter>

	<chapter>
		<title>Associations, Identity, Composition</title>
		<para>
			Let assume we get some more requirements:
			<itemizedlist>
				<listitem>
					<para>
						provide a grouping concept:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								besides persons an address list should also contain an arbitrary number of groups
							</para>
						</listitem>
						<listitem>
							<para>
								groups should be identified by a simple name
							</para>
						</listitem>
						<listitem>
							<para>
								it should be possible to associate persons with groups freely (many to many)
							</para>
						</listitem>
						 <listitem>
							<para>
								it should be possible for a group to form a hierarchy of subgroups with arbitrary depth
							 </para>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</para>

		<section>
			<title>Composition</title>
			<para>
				The first step is to define the groups as new elements of our addressbook.
			</para>

			<formalpara>
				<title>New file model/org/me/addressbook/Group.xml:</title>
				<para>
				   <programlisting><newcode><![CDATA[<beantype name="org.me.addressbook.Group">
    <property name="name"/>
</beantype>]]></newcode></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>File model/org/me/addressbook/Addressbook.xml:</title>
				<para>
				   <programlisting><![CDATA[<beantype name="org.me.addressbook.Addressbook">
    <property name="persons" type="association"
        composition="true"
        targettype="Person"
        sorting="byPropertyValues: lastname, firstname, dateofbirth"
    />]]><newcode><![CDATA[
    <property name="groups" type="association"
        composition="true"
        targettype="Group"
        sorting="byPropertyValues: name"
    />]]></newcode><![CDATA[
    <xmlbinding xmlrootelement="addressbook"/>
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<para>
				The new GUI texts for groups consist in 4 new definitions.
			</para>

			<formalpara>
				<title>File: res/org/me/addressbook/lang/en/res.xml:</title>
				<para>
					<programlisting><![CDATA[bean.org.me.addressbook.addressbook=Address Book
bean.org.me.addressbook.addressbook.id=Address Book
]]><newcode><![CDATA[bean.org.me.addressbook.group=Group
bean.org.me.addressbook.group.id={name}
bean.org.me.addressbook.group.plural=Groups
bean.org.me.addressbook.group.prop.name=Name]]></newcode><![CDATA[
bean.org.me.addressbook.person=Person
bean.org.me.addressbook.person.id={lastname}, {firstname}
bean.org.me.addressbook.person.plural=Persons
bean.org.me.addressbook.person.prop.dateofbirth=Date of birth
bean.org.me.addressbook.person.prop.firstname=First name
bean.org.me.addressbook.person.prop.height=Height
bean.org.me.addressbook.person.prop.lastname=Last name
bean.org.me.addressbook.person.prop.sex=Sex
bean.org.me.addressbook.person.prop.shoesize=Shoe size
enum.org.me.addressbook.sex.male=male
enum.org.me.addressbook.sex.female=female
enum.org.me.addressbook.unitlength.centimeter=cm
enum.org.me.addressbook.unitlength.meter=m
mainwindow.title=Address Book]]></programlisting>
				</para>
			</formalpara>

			<para>
				Although a group's name in this phase is not yet a unique
				identifier in the sense of data modelling you may already
				define it to be presented in the GUI in order to describe
				a specific group instance.
				The plural name of a class will be used to specify the
				association properties with multiplicity > 1.
			</para>
		</section>

		<section>
			<title>Identity and normal associations</title>
			<para>
				For the many-to-many association between Persons and Groups we have to define
				<itemizedlist>
					<listitem><para>the association itself as a pair of <phrase>association properties</phrase></para></listitem>
					<listitem>
						<para>
							an identity concept for persons and groups:
							The definition of an identity is mandatory for classes that are target class of
							an association property because otherwise the concrete links between objects could
							not be persisted.
						</para>
						<itemizedlist>
							<listitem>
								<para>
									Group IDs simply come from the group’s name which is then called
									<phrase>key property</phrase> and also <phrase>speaking or natural key.</phrase>
								</para>
							</listitem>
							<listitem>
								<para>
									Person ID’s on the other hand are generated <phrase>universal unique identifiers</phrase>
									or <phrase>UUIDs</phrase>. UUIDs are also called <phrase>synthetic keys</phrase>).
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
			</para>

			<formalpara>
				<title>File /org/me/addressbook/Group.xml:</title>
				<para>
				   <programlisting><![CDATA[<beantype name="org.me.addressbook.Group" 
    ]]><newcode><![CDATA[idtype="keyprops"]]></newcode><![CDATA[>
    <property name="name" ]]><newcode><![CDATA[key="true"]]></newcode><![CDATA[/>
    ]]><newcode><![CDATA[<property name="persons" type="association"
        targettype="Person"
        inverse="groups"
    />]]></newcode><![CDATA[
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>File /org/me/addressbook/Person.xml:</title>
				<para>
				   <programlisting><![CDATA[<beantype name="org.me.addressbook.Person"
    ]]><newcode><![CDATA[idtype="uuid"]]></newcode><![CDATA[>
    <property name="lastname"/>
    <property name="firstname"/>
    <property name="dateofbirth" type="date"/>
    <property name="shoesize" type="integer"
        minval="15" maxval="60"
    />
    <property name="sex" type="choice"
        enum="Sex"
    />
    <property name="height" type="quantity"
        quantity="Length
    />
    ]]><newcode><![CDATA[<property name="groups" type="association"
        targettype="Group"
        inverse="persons"
    />]]></newcode><![CDATA[
</beantype>]]></programlisting>
				</para>
			</formalpara>
			<figure>
				<title>Persons associated to groups</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image04a.jpg"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<title>Reflexive associations</title>
			<para>
				The last task is the definition of a <phrase>reflexive</phrase> composition association
				for the groups so they can build up a hierarchy:
			</para>

			<formalpara>
				<title>File /org/me/addressbook/Group.xml:</title>
				<para>
				   <programlisting><![CDATA[<beantype name="org.me.addressbook.Group"
        idtype="keyprops">
    <property name="name" key="true"/>
    <property name="persons" type="association"
        targettype="Person"
        inverse="groups"
    />
    ]]><newcode><![CDATA[<property name="subgroups" type="association"
        targettype="Group"
        composition="true"
    />]]></newcode><![CDATA[
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<para>
				Let's play a little bit around with the <phrase>multiplicity</phrase>
				constraint of the Person's type groups association property:

				<programlisting><![CDATA[    <property name="groups" type="association"
        targettype="Person"
        ]]><newcode><![CDATA[maxmult="1"]]></newcode><![CDATA[
        inverse="persons"
    />]]></programlisting>
				This way we define a one to many association between Group and Person.
			</para>

			<para>
				Of course defining a one to one association is not a big deal too.
				Simply add the same constraint to the Group's persons association.

				<programlisting><![CDATA[    <property name="persons" type="association"
        targettype="Group"
        ]]><newcode><![CDATA[maxmult="1"]]></newcode><![CDATA[
        inverse="groups"
    />]]></programlisting>
			</para>

			<figure>
				<title>A tree of groups</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image04b.jpg"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				In order to review all the model enhancements done in the last
				two chapters, let’s have a look at the following UML diagram:
			</para>

			<figure>
				<title>the enhanced domain model</title>
				<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="RapidBeansGettingStarted-files/image04c.gif"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</chapter>

	<chapter>
		<title>Menus and actions</title>
		<para>
			If you have some further 10 minutes you could make a try
			to add new functionality to the appliction by means of a small action.
		</para>
		<section>
			<title>Adding the application configuration file</title>
			<para>
				The first work you have to do is to add small central configuration
				file to your application that allows you to configure some important
				application aspects. Simply create a new model file in package
				org.me.addressbook. Please note that while all the other model files
				define business logic or domain types (Beans, enumerations, quantities)
				this special model file defines the application's UI at one central
				point.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><newcode><![CDATA[<applicationcfg
    name="Addressbook"
    rootpackage="org.me.Addressbook"
    >
    <locale name="de"/>
    <locale name="en"/>
    <mainwindow name="mainwindow">
        <menubar name="menubar">
            <menu name="file">
                <menuitem name="new">
                    <action classname="org.rapidbeans.service.ActionDocumentNew">
                        <argument name="rootclass" value="org.me.addressbook.Addressbook"/>
                    </action>
                </menuitem>
                <menuitem name="open">
                    <action classname="org.rapidbeans.service.ActionDocumentOpen"/>
                </menuitem>
                <menuitem name="close">
                    <action classname="org.rapidbeans.service.ActionActiveViewClose"/>
                    <enabler classname="org.rapidbeans.presentation.enabler.EnablerActiveViewClose"/>
                </menuitem>
                <separator/>
                <menuitem name="save">
                    <action classname="org.rapidbeans.service.ActionDocumentSave"/>
                    <enabler classname="org.rapidbeans.presentation.enabler.EnablerDocumentSave"/>
                </menuitem>
                <menuitem name="saveas">
                    <action classname="org.rapidbeans.service.ActionDocumentSaveAs"/>
                    <enabler classname="org.rapidbeans.presentation.enabler.EnablerDocumentSaveAs"/>
                </menuitem>
                <separator/>
                <historyopendocument/>
                <separator/>
                <menuitem name="quit">
                    <action classname="org.rapidbeans.service.ActionQuit"/>
                </menuitem>
            </menu>
            <menu name="admin">
                <menuitem name="settings">
                    <action classname="org.rapidbeans.service.ActionSettings"/>
                </menuitem>
            </menu>
        </menubar>
    </mainwindow>
</applicationcfg>]]></newcode></programlisting>
				</para>
			</formalpara>
		</section>

		<section>
			<title>Defining a first action</title>
			<para>
			It is fairly simple to add an additional menu item to your addressbook application.
			You simply define it in Application.xml:
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[
                <menuitem name="quit">
				...
                    <action classname="org.rapidbeans.service.ActionQuit"/>
                </menuitem>
            </menu>]]><newcode><![CDATA[
            <menu name="edit">
                <menuitem name="dosomething">
                    <action classname="org.me.addressbook.DoSomethingAction"/>
                </menuitem>
            </menu>]]></newcode><![CDATA[
            <menu name="admin">
                <menuitem name="settings">
                    <action classname="org.rapidbeans.service.ActionSettings"/>
                </menuitem>
            </menu>
            ...]]></programlisting>
				</para>
			</formalpara>
			<para>
				At this point you will have to code something in Java the first time.
				However looking at the code you'll see that this isn't a big deal.
			</para>
			<formalpara>
				<title>File src/org/me/addressbook/DoSomethingAction.java:</title>
				<para>
					<programlisting><newcode><![CDATA[package org.me.addressbook;

import org.rapidbeans.presentation.ApplicationManager;
import org.rapidbeans.service.Action;

public class DoSomethingAction extends Action {
    @Override
    public void execute() {
        ApplicationManager.getApplication().messageInfo("Hello!!!");
    }
}]]></newcode></programlisting>
				</para>
			</formalpara>
			<para>
				Once you have managed to edit and compile this little piece of
				code to the appropriate target file:
				classes/org/me/addressbook/DoSomethingAction.class
				you will see your first action working.
			</para>
			<para>
				Having accomplished this exercise successfully you might like
				to do a little bit more than just say "Hello". For instance you
				might want to provide a tiny address list report instead.
			</para>
			<formalpara>
				<title>File src/org/me/addressbook/DoSomethingAction.java:</title>
				<para>
					<programlisting><newcode><![CDATA[package org.me.addressbook;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.rapidbeans.core.basic.RapidBean;
import org.rapidbeans.datasource.Document;
import org.rapidbeans.presentation.Application;
import org.rapidbeans.presentation.ApplicationManager;
import org.rapidbeans.service.Action;

public class DoSomethingAction extends Action {
    @Override
    public void execute() {
        final Application app = ApplicationManager.getApplication();
        final Document doc = app.getActiveDocument();
        final StringBuffer sb = new StringBuffer();
        for (final RapidBean bean : doc.findBeansByQuery("org.me.addressbook.Person")) {
            sb.append("Person: ");
            sb.append(bean.getPropValue("lastname"));
            sb.append(", ");
            sb.append(bean.getPropValue("firstname"));
            sb.append(", groups: ");
            final List<RapidBean> groups = (List<RapidBean>) bean.getPropValue("groups");
            for (int i = 0; i < groups.size(); i++) {
                if (i > 0) {
                    sb.append(", ");
                }
                sb.append(groups.get(i).getPropValue("name"));
            }
            sb.append('\n');
        }
        app.messageInfo(sb.toString(), "Address List Report");
    }
}]]></newcode></programlisting>
				</para>
			</formalpara>

			<para>
				Additionally you can define a menu text and a menu icon using the already known
				resource mechanism.
			</para>

			<formalpara>
				<title>File res/org/me/addressbook/lang/en/gui.properties</title>
				<para>
					<programlisting><newcode><![CDATA[mainwindow.menubar.edit.dosomething.label=Address list]]></newcode></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>File res/org/me/addressbook/presentation/gui.properties</title>
				<para>
					<programlisting><newcode><![CDATA[mainwindow.menubar.edit.dosomething.icon=icons/addresslist.png]]></newcode></programlisting>
				</para>
			</formalpara>

			<figure>
				<title>Example action</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image05a.jpg" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<title>Using a tool bar</title>

			<para>
				A (cool) tool bar makes your application looking even fancier.
			</para>

			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[    ...
    <mainwindow name="mainwindow">
        ]]><newcode><![CDATA[<toolbar name="all">
            <button name="dosomething">
                <action classname="org.me.addressbook.DoSomethingAction"/>    		
            </button>
        </toolbar>]]></newcode><![CDATA[
        <menubar name="menubar">
    ...]]></programlisting>
				</para>
			</formalpara>

			<para>
				Especially if equipped with an icon and a tool top.
			</para>

			<formalpara>
				<title>File res/org/me/addressbook/presentation/gui.properties</title>
				<para>
					<programlisting><newcode><![CDATA[mainwindow.toolbar.all.dosomething.icon=icons/addresslist32.png]]></newcode></programlisting>
				</para>
			</formalpara>

			<formalpara>
				<title>File res/org/me/addressbook/lang/en/gui.properties</title>
				<para>
					<programlisting><newcode><![CDATA[mainwindow.toolbar.all.dosomething.tooltip=Tiny address list report]]></newcode></programlisting>
				</para>
			</formalpara>

			<figure>
				<title>Tool bar and tool tip</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image05b.jpg" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<title>Using enablers</title>
			<para>
				A last exercise concerning menus and actions is involving a
				so called "enabler". An enabler controls if a certain
				UI element (widget) is sensitive for user input. Like with
				the action you simply refer to a specific enabler subclass.
				The enabler of our new address list report for instance could
				check if currently an address book is opened which is reasonable
				because the report as it is implemented now will break with
				a NullPointeException if no document is opened. Let's start
				defining the enabler for the toolbar button.
			</para>

			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[
    ...
    <mainwindow name="mainwindow">
        <toolbar name="all">
            <button name="dosomething">
                <action="org.me.addressbook.DoSomethingAction"/>
                ]]><newcode><![CDATA[<enabler classname="org.me.addressbook.DoSomethingEnabler"/>]]></newcode><![CDATA[
            </button>
        </toolbar>
        <menubar name="menubar">
     ...]]></programlisting>
				</para>
			</formalpara>

			<para>
				Next you should also add the enabler reference to the menu
				item.
			</para>

			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[
    ...
            <menu name="edit">
                <menuitem name="dosomething">
                    <action classname="org.me.addressbook.DoSomethingAction"/>
                    ]]><newcode><![CDATA[<enabler classname="org.me.addressbook.DoSomethingEnabler"/>]]></newcode><![CDATA[
                </menuitem>
             </menu>
     ...]]></programlisting>
				</para>
			</formalpara>

			<para>
				Coding the enabler class is not too hard. Simply derive it
				from the framework's base enabler and implement method getEnabled().
				The following implementation only returns true if an address book
				is the active document.
			</para>

						<formalpara>
				<title>File src/org/me/addressbook/DoSomethingAction.java:</title>
				<para>
					<programlisting><newcode><![CDATA[package org.me.addressbook;

import org.rapidbeans.core.type.TypeRapidBean;
import org.rapidbeans.presentation.Application;
import org.rapidbeans.presentation.ApplicationManager;
import org.rapidbeans.presentation.enabler.Enabler;

public class DoSomethingEnabler extends Enabler {

    @Override
    public boolean getEnabled() {
        final Application app = ApplicationManager.getApplication();
        if (app.getActiveDocument() == null
                || app.getActiveDocument().getRoot().getType()
                    != TypeRapidBean.forName("org.me.addressbook.Addressbook")) {
            return false;
        }
        return true;
    }
}]]></newcode></programlisting>
				</para>
			</formalpara>

			<para>
				Once you've implemented the enabler the toolbar and the menu
				item should be disabled as soon as the address list document
				view is closed.
			</para>

			<figure>
				<title>Toolbar button and menu entry disabled</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image05c.jpg" />
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Since you now defined a reference for one and the same enabler
				two times you could alternatively avoid redundancy by referencing
				the enabler at the action once. In order to accomplish this
				use a centralized action definition ass shown below.
			</para>

			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[
    ...
    <locale name="en"/>
    ]]><newcode><![CDATA[<action classname="org.me.addressbook.DoSomethingAction">
        <enabler classname="org.me.addressbook.DoSomethingEnabler"/>
    </action>]]></newcode><![CDATA[
    <mainwindow name="mainwindow">
        <toolbar name="all">
            ]]><changedcode><![CDATA[<button name="dosomething"
                action="org.me.addressbook.DoSomethingAction"
            />]]></changedcode><![CDATA[
        </toolbar>
        <menubar name="menubar">
     ....
            <menu name="edit">
                 ]]><changedcode><![CDATA[<menuitem name="dosomething"
                     action="org.me.addressbook.DoSomethingAction"
                 />]]></changedcode><![CDATA[
            </menu>
     ...]]></programlisting>
				</para>
			</formalpara>

		</section>

	</chapter>

	<chapter>
		<title>Authentication and authorization</title>
		<para>
			Even in the early design phase you might want to introduce security
			features involving authentication and authorization especially when
			planning multi user support. RapidBeans supports authentication and
			authorization in a very simple manner already a model level.
		</para>
		<section>
			<title>Simple user account with password authentication</title>
			<para>
				The first work is to configure the application in order to
				involve authentication by defining the authentication method
				and a realm which basically is a simple database with users
				and passwords.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Application.xml</title>
				<para>
					<programlisting><![CDATA[<applicationcfg
	name="MyAddressbook"
	rootpackage="org.me.addressbook"
	>
	<locale name="de"/>
	<locale name="en"/>
	]]><newcode><![CDATA[<authorization
		authenticationmethod="userpassword"
		realm="file:testdata/realm.xml"
	/>]]></newcode><![CDATA[
	<mainwindow name="mainwindow">
	. . .]]></programlisting>
				</para>
			</formalpara>
			<para>
				The Realm bean type simply is a container of users.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Realm.xml</title>
				<para>
					<programlisting><newcode><![CDATA[<beantype name="org.me.addressbook.Realm">
    <property name="users" type="association"
        composition="true"
        targettype="org.rapidbeans.security.User"
        sorting="byPropertyValues: accountname"
    />
</beantype>]]></newcode></programlisting>
				</para>
			</formalpara>
			<para>
				The realm at least has to define one initial user
				which we'll use for the first logon.
			</para>
			<formalpara>
				<title>File testdata/realm.xml</title>
				<para>
					<programlisting><newcode><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<rb:bean xmlns:rb="http://rapidbeans.org/core/basic"
	rb:type="org.me.addressbook.Realm"
	>
	<user
		id="user1"
		accountname="user1"
		/>
</rb:bean>]]></newcode></programlisting>
				</para>
			</formalpara>
			<para>
				Having entered these few definitions the next time
				you start the application a logon dialog will prompt
				you for a user account and a password.
			</para>
			<figure>
				<title>Logon dialog</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image06a.jpg" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				Simply type in the user account name defined in the realm
				and leave the password field empty since we haven't defined
				a password so far.
			</para>
			<para>
				Of course you now could load the realm into your Addressbook
				application and for instance create a second user and / or add give
				the user a password.
			</para>
			<figure>
				<title>Realm with second user while setting the password</title>
				<mediaobject>
					<imageobject>
						<imagedata format="JPG" fileref="RapidBeansGettingStarted-files/image06b.jpg" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<title>Role based authorization</title>
			<para>
				In most cases authentication goes hand in hand with authorization.
				Even in our small authentication example there was implicitly also
				authorization involved because users that could not authenticate
				where not able to start the application. In order to diffentiate
				permissions for distinct users the simplest mean is to:
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>define a set of roles users could have while working with the application</para>
					</listitem>
					<listitem>
						<para>hardwire access permissions to arbitrary application resources with one ore more role</para>
					</listitem>
					<listitem>
						<para>associate concrete user instances with these roles at runtime</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				In order to accomplish the 1st and the 3rd item you have to
			</para>
			<para>
				Define the roles as enum specificly for your application.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Role.xml</title>
				<para>
					<programlisting><newcode><![CDATA[<enumtype name="org.me.addressbook.Role">
    <enum name="user"/>
    <enum name="administrator"/>
    <enum name="superadministrator"/>
</enumtype>]]></newcode></programlisting>
				</para>
			</formalpara>
			<para>
				Derive the framework's user class in order to be associated with these roles.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/User.xml</title>
				<para>
					<programlisting><newcode><![CDATA[<beantype name="org.me.addressbook.User"
    extends="org.rapidbeans.security.User">
    <property name="roles"
        type="choice"
        enum="org.me.addressbook.Role"
    />
</beantype>]]></newcode></programlisting>
				</para>
			</formalpara>
			<para>
				Change the Realm type to collect these users.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Realm.xml</title>
				<para>
					<programlisting><![CDATA[<beantype name="org.me.addressbook.Realm">
    <property name="users" type="association"
        composition="true"
        ]]><newcode><![CDATA[targettype="org.me.addressbook.User"]]></newcode><![CDATA[
        sorting="byPropertyValues: accountname"
    />
</beantype>]]></programlisting>
				</para>
			</formalpara>

			<para>
				Define the new Role type in the Application configuration's authorization part.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Application.xml</title>
				<para>
					<programlisting><![CDATA[<applicationcfg name="MyAddressbook" rootpackage="org.me.addressbook">
    <locale name="de"/>
    <locale name="en"/>
    <authorization
        authenticationmethod="userpassword"
        realm="file:testdata/realm.xml"
        ]]><newcode><![CDATA[roletype="org.me.addressbook.Role"]]></newcode><![CDATA[
    />
    ...]]></programlisting>
				</para>
			</formalpara>

			<para>
				Extend the resource definitions (optional).
			</para>
			<formalpara>
				<title>File res/org/me/addressbook/lang/en/gui.properties</title>
				<para>
					<programlisting><![CDATA[bean.org.me.addressbook.person.prop.shoesize=Shoe size
]]><newcode><![CDATA[bean.org.me.addressbook.user.prop.roles=Role
enum.org.me.addressbook.role.administrator=Administrator
enum.org.me.addressbook.role.superadministrator=Super Administrator
enum.org.me.addressbook.role.user=User]]></newcode><![CDATA[
enum.org.me.addressbook.sex.male=male]]></programlisting>
				</para>
			</formalpara>
			<para>
				It would be no big deal if you want to associate more
				than one role to a user. Simply set multiple = "true"
				in the "roles" property definition of your "User" bean
				definition. In change you may omit the overdefinition
				of the roles prop name in the UI resources file
				gui.properties.
			</para>
			<para>
				In order to hardwire the roles with concrete application
				permissions you can use declarative means as well as
				programmatical ones. For instance you might want to
				allow only superadministrator's to change the realm.
				In order to accomplish this you could declare so required
				roles for read or write access for the realm document.
			</para>
			<formalpara>
				<title>File model/org/me/addressbook/Application.xml</title>
				<para>
					<programlisting><![CDATA[<applicationcfg
	name="MyAddressbook"
	rootpackage="org.me.addressbook"
	>
	<locale name="de"/>
	<locale name="en"/>
	<authorization
		authenticationmethod="userpassword"
		realm="file:testdata/realm.xml"
		roletype="org.me.addressbook.Role"
	/>
	]]><newcode><![CDATA[<document name="realm"
		rootclass="org.me.addressbook.Realm"
		readaccessrolesrequired="administrator,superadministrator"
		writeaccessrolesrequired="superadministrator"
	/>]]></newcode><![CDATA[
	<mainwindow name="mainwindow">]]></programlisting>
				</para>
			</formalpara>

			<para>
				As a result user "user" won't be able to open the
				realm document anymore while user "admin" will only
				have read access to the realm. Only user "super"
				will have full access like before.
			</para>

			<para>
				You can also easily add authorization rules to some
				actions of your application. For instance you might want to
				permit access to the new "address list report" function only
				for super adminstrators and (normal) administrators. In that
				case you simply add some annotation to the DoSomethingAction:
			</para>

			<formalpara>
				<title>File model/org/me/addressbook/Application.xml:</title>
				<para>
					<programlisting><![CDATA[
    ...
    <action classname="org.me.addressbook.DoSomethingAction"
        ]]><newcode><![CDATA[rolesrequired="administrator,superadministrator"]]></newcode><![CDATA[>
        <enabler classname="org.me.addressbook.DoSomethingEnabler"/>
    </action>
     ...]]></programlisting>
				</para>
			</formalpara>

			<para>
				As a result the toolbar button and the menu entry for this action
				won't be visible as soon as you log in as normal user.
			</para>

			<para>
				Checking role based authorization programmatically gives you more
				fine grained control over your application's authorization behavior.
				For instance you could want that only super administrators may use
				the address list report but administrators at least see this
				functionality in a disabled manner. A small adaption to the enabler
				we've already written will make that happen.
			</para>

			<formalpara>
				<title>File src/org/me/addressbook/DoSomethingAction.java:</title>
				<para>
					<programlisting><![CDATA[package org.me.addressbook;

import org.rapidbeans.core.type.TypeRapidBean;
import org.rapidbeans.presentation.Application;
import org.rapidbeans.presentation.ApplicationManager;
import org.rapidbeans.presentation.enabler.Enabler;]]><newcode><![CDATA[
import org.rapidbeans.security.User;]]></newcode><![CDATA[

public class DoSomethingEnabler extends Enabler {

    @Override
    public boolean getEnabled() {
        final Application app = ApplicationManager.getApplication();
        if (app.getActiveDocument() == null
                || app.getActiveDocument().getRoot().getType()
                    != TypeRapidBean.forName("org.me.addressbook.Addressbook")) {
            return false;
        }]]><changedcode><![CDATA[
        return User.hasRoleGeneric(
                app.getAuthenticatedUser(), "superadministrator");]]></changedcode><![CDATA[
    }
}]]></programlisting>
				</para>
			</formalpara>
			<para>
				Small note: using the static method
				<emphasis>User.hasRoleGeneric()</emphasis> is a tribute to working
				with generic bean types here. If we already would use code generation
				and had a real Java class derived from the framework's User class
				we rather would use the non static variant
				<emphasis>app.getAuthenticatedUser().hasRole()</emphasis>.
			</para>
		</section>
		<section>
			<title>Authorization on application resources</title>
			<para>
				???
			</para>
		</section>
	</chapter>

	<chapter>
		<title>Generating code</title>
		<para>
			If you have some further 10 minutes you could make a try
			with the RapidBeans code generation.
		</para>
		<section>
			<title>Introducing simple code generation</title>
			<para>
				(In work)
			</para>
		</section>
	</chapter>
</book>
